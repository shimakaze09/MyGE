//
// Created by Admin on 17/03/2025.
//

#include <MyGE/App/D3DApp/D3DApp.h>
#include <MyGE/Core/GameTimer.h>

using Microsoft::WRL::ComPtr;
using namespace My::MyGE;
using namespace DirectX;
using namespace std;

D3DApp::D3DApp(HINSTANCE hInstance) : mhAppInst(hInstance) {
  // Only one D3DApp can be constructed.
  assert(mApp == nullptr);
  mApp = this;
}

D3DApp::~D3DApp() {
  if (!myDevice.IsNull()) FlushCommandQueue();
}

LRESULT CALLBACK D3DApp::MainWndProc(HWND hwnd, UINT msg, WPARAM wParam,
                                     LPARAM lParam) {
  // Forward hwnd on because we can get messages (e.g., WM_CREATE)
  // before CreateWindow returns, and thus before mhMainWnd is valid.
  return D3DApp::GetApp()->MsgProc(hwnd, msg, wParam, lParam);
}

int D3DApp::Run() {
  MSG msg = {0};

  My::MyGE::GameTimer::Instance().Reset();

  while (msg.message != WM_QUIT) {
    // If there are Window messages then process them.
    if (PeekMessage(&msg, 0, 0, 0, PM_REMOVE)) {
      TranslateMessage(&msg);
      DispatchMessage(&msg);
    } else {  // Otherwise, do animation/game stuff.
      My::MyGE::GameTimer::Instance().Tick();

      if (!mAppPaused) {
        CalculateFrameStats();
        Update();
        Draw();
      } else
        Sleep(100);
    }
  }

  return (int)msg.wParam;
}

void D3DApp::CreateRtvAndDsvDescriptorHeaps() {
  D3D12_DESCRIPTOR_HEAP_DESC rtvHeapDesc;
  rtvHeapDesc.NumDescriptors = SwapChainBufferCount;
  rtvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_RTV;
  rtvHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_NONE;
  rtvHeapDesc.NodeMask = 0;
  ThrowIfFailed(myDevice->CreateDescriptorHeap(
      &rtvHeapDesc, IID_PPV_ARGS(mRtvHeap.GetAddressOf())));

  D3D12_DESCRIPTOR_HEAP_DESC dsvHeapDesc;
  dsvHeapDesc.NumDescriptors = 1;
  dsvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_DSV;
  dsvHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_NONE;
  dsvHeapDesc.NodeMask = 0;
  ThrowIfFailed(myDevice->CreateDescriptorHeap(
      &dsvHeapDesc, IID_PPV_ARGS(mDsvHeap.GetAddressOf())));
}

void D3DApp::OnResize() {
  assert(!myDevice.IsNull());
  assert(mSwapChain);
  assert(mDirectCmdListAlloc);

  // Flush before changing any resources.
  FlushCommandQueue();

  ThrowIfFailed(uGCmdList->Reset(mDirectCmdListAlloc.Get(), nullptr));

  // Release the previous resources we will be recreating.
  for (int i = 0; i < SwapChainBufferCount; ++i) mSwapChainBuffer[i].Reset();
  mDepthStencilBuffer.Reset();

  // Resize the swap chain.
  ThrowIfFailed(mSwapChain->ResizeBuffers(
      SwapChainBufferCount, mClientWidth, mClientHeight, mBackBufferFormat,
      DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH));

  mCurrBackBuffer = 0;

  CD3DX12_CPU_DESCRIPTOR_HANDLE rtvHeapHandle(
      mRtvHeap->GetCPUDescriptorHandleForHeapStart());
  for (UINT i = 0; i < SwapChainBufferCount; i++) {
    ThrowIfFailed(mSwapChain->GetBuffer(i, IID_PPV_ARGS(&mSwapChainBuffer[i])));
    myDevice->CreateRenderTargetView(mSwapChainBuffer[i].Get(), nullptr,
                                     rtvHeapHandle);
    rtvHeapHandle.Offset(1, mRtvDescriptorSize);
  }

  // Create the depth/stencil buffer and view.
  D3D12_RESOURCE_DESC depthStencilDesc;
  depthStencilDesc.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D;
  depthStencilDesc.Alignment = 0;
  depthStencilDesc.Width = mClientWidth;
  depthStencilDesc.Height = mClientHeight;
  depthStencilDesc.DepthOrArraySize = 1;
  depthStencilDesc.MipLevels = 1;

  // Correction 11/12/2016: SSAO chapter requires an SRV to the depth buffer to
  // read from the depth buffer.  Therefore, because we need to create two views
  // to the same resource:
  //   1. SRV format: DXGI_FORMAT_R24_UNORM_X8_TYPELESS
  //   2. DSV Format: DXGI_FORMAT_D24_UNORM_S8_UINT
  // we need to create the depth buffer resource with a typeless format.
  depthStencilDesc.Format = DXGI_FORMAT_R24G8_TYPELESS;

  depthStencilDesc.SampleDesc.Count = 1;
  depthStencilDesc.SampleDesc.Quality = 0;
  depthStencilDesc.Layout = D3D12_TEXTURE_LAYOUT_UNKNOWN;
  depthStencilDesc.Flags = D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL;

  D3D12_CLEAR_VALUE optClear;
  optClear.Format = mDepthStencilFormat;
  optClear.DepthStencil.Depth = 1.0f;
  optClear.DepthStencil.Stencil = 0;
  ThrowIfFailed(myDevice->CreateCommittedResource(
      &CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT), D3D12_HEAP_FLAG_NONE,
      &depthStencilDesc, D3D12_RESOURCE_STATE_COMMON, &optClear,
      IID_PPV_ARGS(mDepthStencilBuffer.GetAddressOf())));

  // Create descriptor to mip level 0 of entire resource using the format of the
  // resource.
  D3D12_DEPTH_STENCIL_VIEW_DESC dsvDesc;
  dsvDesc.Flags = D3D12_DSV_FLAG_NONE;
  dsvDesc.ViewDimension = D3D12_DSV_DIMENSION_TEXTURE2D;
  dsvDesc.Format = mDepthStencilFormat;
  dsvDesc.Texture2D.MipSlice = 0;
  myDevice->CreateDepthStencilView(mDepthStencilBuffer.Get(), &dsvDesc,
                                   DepthStencilView());

  // Transition the resource from its initial state to be used as a depth
  // buffer.
  uGCmdList->ResourceBarrier(
      1, &CD3DX12_RESOURCE_BARRIER::Transition(
             mDepthStencilBuffer.Get(), D3D12_RESOURCE_STATE_COMMON,
             D3D12_RESOURCE_STATE_DEPTH_WRITE));

  // Execute the resize commands.
  ThrowIfFailed(uGCmdList->Close());
  myCmdQueue.Execute(uGCmdList.raw.Get());

  // Wait until resize is complete.
  FlushCommandQueue();
}

bool D3DApp::InitMainWindow() {
  WNDCLASS wc;
  wc.style = CS_HREDRAW | CS_VREDRAW;
  wc.lpfnWndProc = MainWndProc;
  wc.cbClsExtra = 0;
  wc.cbWndExtra = 0;
  wc.hInstance = mhAppInst;
  wc.hIcon = LoadIcon(0, IDI_APPLICATION);
  wc.hCursor = LoadCursor(0, IDC_ARROW);
  wc.hbrBackground = (HBRUSH)GetStockObject(NULL_BRUSH);
  wc.lpszMenuName = 0;
  wc.lpszClassName = L"MainWnd";

  if (!RegisterClass(&wc)) {
    MessageBox(0, L"RegisterClass Failed.", 0, 0);
    return false;
  }

  // Compute window rectangle dimensions based on requested client area
  // dimensions.
  RECT R = {0, 0, mClientWidth, mClientHeight};
  AdjustWindowRect(&R, WS_OVERLAPPEDWINDOW, false);
  int width = R.right - R.left;
  int height = R.bottom - R.top;

  mhMainWnd = CreateWindow(L"MainWnd", mMainWndCaption.c_str(),
                           WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT,
                           width, height, 0, 0, mhAppInst, 0);
  if (!mhMainWnd) {
    MessageBox(0, L"CreateWindow Failed.", 0, 0);
    return false;
  }

  ShowWindow(mhMainWnd, SW_SHOW);
  UpdateWindow(mhMainWnd);

  return true;
}

bool D3DApp::InitDirect3D() {
#if defined(DEBUG) || defined(_DEBUG)
  // Enable the D3D12 debug layer.
  {
    ComPtr<ID3D12Debug> debugController;
    ThrowIfFailed(D3D12GetDebugInterface(IID_PPV_ARGS(&debugController)));
    debugController->EnableDebugLayer();
  }
#endif

  ThrowIfFailed(CreateDXGIFactory1(IID_PPV_ARGS(&mdxgiFactory)));

  // Try to create hardware device.
  HRESULT hardwareResult =
      D3D12CreateDevice(nullptr,  // default adapter
                        D3D_FEATURE_LEVEL_11_0, IID_PPV_ARGS(&myDevice.raw));

  // Fallback to WARP device.
  if (FAILED(hardwareResult)) {
    ComPtr<IDXGIAdapter> pWarpAdapter;
    ThrowIfFailed(mdxgiFactory->EnumWarpAdapter(IID_PPV_ARGS(&pWarpAdapter)));

    ThrowIfFailed(D3D12CreateDevice(pWarpAdapter.Get(), D3D_FEATURE_LEVEL_11_0,
                                    IID_PPV_ARGS(&myDevice.raw)));
  }

  ThrowIfFailed(myDevice->CreateFence(mCurrentFence, D3D12_FENCE_FLAG_NONE,
                                      IID_PPV_ARGS(&mFence)));

  mRtvDescriptorSize = myDevice->GetDescriptorHandleIncrementSize(
      D3D12_DESCRIPTOR_HEAP_TYPE_RTV);
  mDsvDescriptorSize = myDevice->GetDescriptorHandleIncrementSize(
      D3D12_DESCRIPTOR_HEAP_TYPE_DSV);
  mCbvSrvUavDescriptorSize = myDevice->GetDescriptorHandleIncrementSize(
      D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);

  D3D12_FEATURE_DATA_MULTISAMPLE_QUALITY_LEVELS msQualityLevels;
  msQualityLevels.Format = mBackBufferFormat;
  msQualityLevels.SampleCount = 4;
  msQualityLevels.Flags = D3D12_MULTISAMPLE_QUALITY_LEVELS_FLAG_NONE;
  msQualityLevels.NumQualityLevels = 0;
  ThrowIfFailed(
      myDevice->CheckFeatureSupport(D3D12_FEATURE_MULTISAMPLE_QUALITY_LEVELS,
                                    &msQualityLevels, sizeof(msQualityLevels)));

#ifdef _DEBUG
  LogAdapters();
#endif

  CreateCommandObjects();
  CreateSwapChain();
  CreateRtvAndDsvDescriptorHeaps();

  return true;
}

void D3DApp::CreateCommandObjects() {
  D3D12_COMMAND_QUEUE_DESC queueDesc = {};
  queueDesc.Type = D3D12_COMMAND_LIST_TYPE_DIRECT;
  queueDesc.Flags = D3D12_COMMAND_QUEUE_FLAG_NONE;
  ThrowIfFailed(
      myDevice->CreateCommandQueue(&queueDesc, IID_PPV_ARGS(&myCmdQueue.raw)));

  ThrowIfFailed(myDevice->CreateCommandAllocator(
      D3D12_COMMAND_LIST_TYPE_DIRECT,
      IID_PPV_ARGS(mDirectCmdListAlloc.GetAddressOf())));

  ThrowIfFailed(myDevice->CreateCommandList(
      0, D3D12_COMMAND_LIST_TYPE_DIRECT,
      mDirectCmdListAlloc.Get(),  // Associated command allocator
      nullptr,                    // Initial PipelineStateObject
      IID_PPV_ARGS(uGCmdList.raw.GetAddressOf())));

  // Start off in a closed state.  This is because the first time we refer
  // to the command list we will Reset it, and it needs to be closed before
  // calling Reset.
  uGCmdList->Close();
}

void D3DApp::CreateSwapChain() {
  // Release the previous swapchain we will be recreating.
  mSwapChain.Reset();

  DXGI_SWAP_CHAIN_DESC sd;
  sd.BufferDesc.Width = mClientWidth;
  sd.BufferDesc.Height = mClientHeight;
  sd.BufferDesc.RefreshRate.Numerator = 60;
  sd.BufferDesc.RefreshRate.Denominator = 1;
  sd.BufferDesc.Format = mBackBufferFormat;
  sd.BufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;
  sd.BufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;
  sd.SampleDesc.Count = 1;
  sd.SampleDesc.Quality = 0;
  sd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
  sd.BufferCount = SwapChainBufferCount;
  sd.OutputWindow = mhMainWnd;
  sd.Windowed = true;
  sd.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD;
  sd.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;

  // Note: Swap chain uses queue to perform flush.
  ThrowIfFailed(mdxgiFactory->CreateSwapChain(myCmdQueue.raw.Get(), &sd,
                                              mSwapChain.GetAddressOf()));
}

D3D12_VIEWPORT D3DApp::GetScreenViewport() const noexcept {
  D3D12_VIEWPORT viewport;
  viewport.TopLeftX = 0;
  viewport.TopLeftY = 0;
  viewport.Width = static_cast<float>(mClientWidth);
  viewport.Height = static_cast<float>(mClientHeight);
  viewport.MinDepth = 0.0f;
  viewport.MaxDepth = 1.0f;
  return viewport;
}

void D3DApp::FlushCommandQueue() {
  // Advance the fence value to mark commands up to this fence point.
  mCurrentFence++;

  // Add an instruction to the command queue to set a new fence point.  Because
  // we are on the GPU timeline, the new fence point won't be set until the GPU
  // finishes processing all the commands prior to this Signal().
  ThrowIfFailed(myCmdQueue->Signal(mFence.Get(), mCurrentFence));

  // Wait until the GPU has completed commands up to this fence point.
  if (mFence->GetCompletedValue() < mCurrentFence) {
    HANDLE eventHandle =
        CreateEventEx(nullptr, nullptr, false, EVENT_ALL_ACCESS);

    // Fire event when GPU hits current fence.
    ThrowIfFailed(mFence->SetEventOnCompletion(mCurrentFence, eventHandle));

    // Wait until the GPU hits current fence event is fired.
    WaitForSingleObject(eventHandle, INFINITE);
    CloseHandle(eventHandle);
  }
}

void D3DApp::SwapBackBuffer() {
  ThrowIfFailed(mSwapChain->Present(0, 0));
  mCurrBackBuffer = (mCurrBackBuffer + 1) % SwapChainBufferCount;
}

D3D12_CPU_DESCRIPTOR_HANDLE D3DApp::CurrentBackBufferView() const noexcept {
  return CD3DX12_CPU_DESCRIPTOR_HANDLE(
      mRtvHeap->GetCPUDescriptorHandleForHeapStart(), mCurrBackBuffer,
      mRtvDescriptorSize);
}

void D3DApp::CalculateFrameStats() {
  // Code computes the average frames per second, and also the
  // average time it takes to render one frame.  These stats
  // are appended to the window caption bar.

  frameCnt++;

  // Compute averages over one second period.
  if ((My::MyGE::GameTimer::Instance().TotalTime() - timeElapsed) >= 1.0f) {
    float fps = (float)frameCnt;  // fps = frameCnt / 1
    float mspf = 1000.0f / fps;

    wstring fpsStr = to_wstring(fps);
    wstring mspfStr = to_wstring(mspf);

    wstring windowText =
        mMainWndCaption + L"    fps: " + fpsStr + L"   mspf: " + mspfStr;

    SetWindowText(mhMainWnd, windowText.c_str());

    // Reset for next average.
    frameCnt = 0;
    timeElapsed += 1.0f;
  }
}

void D3DApp::LogAdapters() {
  UINT i = 0;
  IDXGIAdapter* adapter = nullptr;
  std::vector<IDXGIAdapter*> adapterList;
  while (mdxgiFactory->EnumAdapters(i, &adapter) != DXGI_ERROR_NOT_FOUND) {
    DXGI_ADAPTER_DESC desc;
    adapter->GetDesc(&desc);

    std::wstring text = L"***Adapter: ";
    text += desc.Description;
    text += L"\n";

    OutputDebugString(text.c_str());

    adapterList.push_back(adapter);

    ++i;
  }

  for (size_t i = 0; i < adapterList.size(); ++i) {
    LogAdapterOutputs(adapterList[i]);
    MyDX12::Util::ReleaseCom(adapterList[i]);
  }
}

void D3DApp::LogAdapterOutputs(IDXGIAdapter* adapter) {
  UINT i = 0;
  IDXGIOutput* output = nullptr;
  while (adapter->EnumOutputs(i, &output) != DXGI_ERROR_NOT_FOUND) {
    DXGI_OUTPUT_DESC desc;
    output->GetDesc(&desc);

    std::wstring text = L"***Output: ";
    text += desc.DeviceName;
    text += L"\n";
    OutputDebugString(text.c_str());

    LogOutputDisplayModes(output, mBackBufferFormat);

    MyDX12::Util::ReleaseCom(output);

    ++i;
  }
}

void D3DApp::LogOutputDisplayModes(IDXGIOutput* output, DXGI_FORMAT format) {
  UINT count = 0;
  UINT flags = 0;

  // Call with nullptr to get list count.
  output->GetDisplayModeList(format, flags, &count, nullptr);

  std::vector<DXGI_MODE_DESC> modeList(count);
  output->GetDisplayModeList(format, flags, &count, &modeList[0]);

  for (auto& x : modeList) {
    UINT n = x.RefreshRate.Numerator;
    UINT d = x.RefreshRate.Denominator;
    std::wstring text = L"Width = " + std::to_wstring(x.Width) + L" " +
                        L"Height = " + std::to_wstring(x.Height) + L" " +
                        L"Refresh = " + std::to_wstring(n) + L"/" +
                        std::to_wstring(d) + L"\n";

    ::OutputDebugString(text.c_str());
  }
}
